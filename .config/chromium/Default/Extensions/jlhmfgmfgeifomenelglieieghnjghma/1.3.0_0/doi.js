/**
 * @Copyright 2016 Cisco Systems Inc. All rights reserved.
 * @Description This is a part of telemetry SDK. base file.
 * @Author Xiaole Tao <xiaolet@cisco.com>
 * @File: main.js
 * @Date 27/12/2016
 */
"use strict";

var doi = {
    conf: {
    //    isUT: typeof describe === "function",
        xhrHeader: {}
    },
    util: {},
    io: {},
    ticker: {
        liveCounter: 0,
        actionRepo: [],

        /**
         * add function to ticker action repo
         * @param {function} fn
         */
        onTick: function (fn) {
            this.actionRepo.push(fn);
        },

        /**
         * remove function to ticker action repo
         * @param fn
         */
        off: function (fn) {
            var index = this.actionRepo.indexOf(fn);
            if (index > -1) {
                this.actionRepo.splice(index, 1);
            }
        },

        /**
         * clear all bind function from ticker repo
         */
        clear: function () {
            this.actionRepo = [];
        },

        /**
         * trigger tick event, will run all function which in action repo
         */
        trigger: function () {
            this.liveCounter++;
            for (var index in this.actionRepo) {
                if (typeof this.actionRepo[index] === "function") {
                    this.actionRepo[index]();
                }
            }
        },

        /**
         * every beat
         */
        intervalTick: function () {
            doi.ticker.trigger();
        }
    }
};

/* istanbul ignore else: browser will not run this if */
if (typeof global !== "undefined") {
    //for nodejs and browser compatible
    doi.conf.inNodeMode = true;
    global.window = global;
    window.XMLHttpRequest = require("xmlhttprequest").XMLHttpRequest;
    module.exports = doi;
}
window.doi = doi;
window.setInterval(doi.ticker.intervalTick, 100);
/* End of file: main.js */

/**
 * @Copyright 2016 Cisco Systems Inc. All rights reserved.
 * @Description This is a part of telemetry SDK.
 * @Depends main.js
 * @Author Xiaole Tao <xiaolet@cisco.com>
 * @File: abbrMapping.js
 * @Date 27/12/2016
 */
(function () {


    var conf = window.doi.conf;

    conf.abbrMapping = {
        "correlateID":      "cid",
        "product":          "pd",
        "telemetryVersion": "ver",
        "timestamp":        "ts",
        "tsID":             "tid",
        "type":             "t",
        "values":           "v"
    };
}());
/* End of file: abbrMapping.js */

/**
 * @Copyright 2017 Cisco Systems Inc. All rights reserved.
 * @Description This is a part of telemetry SDK.
 * @depends main.js, abbrMapping.js
 * @Author Xiaole Tao <xiaolet@cisco.com>
 * @File abbreviator.js
 * @Date 03/01/2017
 */
(function () {


    var doi = window.doi,
        conf = doi.conf,
        util = doi.util;

    /**
     * @param param
     * @returns {boolean}
     * @private
     */
    function _isArray(param) {
        return Object.prototype.toString.call(param) === "[object Array]";
    }

    /**
     * @param param
     * @returns {boolean}
     * @private
     */
    function _isObject(param) {
        return Object.prototype.toString.call(param) === "[object Object]";
    }

    /**
     * @param param
     * @returns {boolean}
     * @private
     */
    function _isValue(param) {
        return !_isArray(param) && !_isObject(param);
    }

    /**
     * transfer key as abbreviated
     * @param {string} key
     * @returns {string}
     */
    function _keyAbbreviator(key) {
        var abbrMapping = conf.abbrMapping;
        for (var abbr in abbrMapping) {
            if (key === abbr) {
                return abbrMapping[abbr];
            }
        }
        return key;
    }

    /**
     * abbreviate object key
     * @param {object} data
     * @returns {object}
     */
    function abbreviate(data) {
        if (_isValue(data)) {
            return data;
        }
        var result = _isArray(data) ? [] : {};
        for (var key in data) {
            result[_keyAbbreviator(key)] = abbreviate(data[key]);
        }
        return result;
    }

    /* istanbul ignore else: export private method for UT */
    //if (conf.isUT) {
    //    //only can see private method in unit test
    //    util._isArray = _isArray;
    //    util._isObject = _isObject;
    //    util._isValue = _isValue;
    //}
    util._keyAbbreviator = _keyAbbreviator;
    util.abbreviate = abbreviate;

}());
/* End of file: abbreviator.js */

/**
 * @Copyright 2017 Cisco Systems Inc. All rights reserved.
 * @Description This is a part of telemetry SDK. Generated by transSchema.js
 * @Depends main.js
 * @Author Xiaole Tao <xiaolet@cisco.com>
 * @File doSchema.js
 * @Date Fri Sep 15 2017 11:34:52 GMT+0800 (CST)
 */
(function () {


    var doi = window.doi,
        conf = doi.conf;

    conf.validation = {
        "AgentInfo": {
            required: ["os", "language", "region", "browser", "timezone"],
            checkList: {
                "os": ["string"],
                "language": ["string"],
                "region": ["string"],
                "browser": ["string"],
                "timezone": ["string"],
                "tzName": ["string"],
                "deviceModel": ["string"],
                "deviceInfo": ["string"],
                "localIP": ["string"],
                "geoLocation": ["string"]
            }
        },
        "Info": {
            required: ["category", "userID", "version"],
            checkList: {
                "category": ["string", ["Conference", "PT", "Call", "Room", "Message", "Session"]],
                "userID": ["string"],
                "version": ["string"],
                "extVal": ["object"]
            }
        },
        "PageView": {
            required: ["title", "location"],
            checkList: {
                "title": ["string"],
                "location": ["string"],
                "page": ["string"],
                "extVal": ["object"]
            }
        },
        "ScreenView": {
            required: ["screenName"],
            checkList: {
                "screenName": ["string"],
                "extVal": ["object"]
            }
        },
        "Action": {
            required: ["category", "action", "uiSource"],
            checkList: {
                "category": ["string"],
                "action": ["string"],
                "uiSource": ["string"],
                "label": ["string"],
                "value": ["string"],
                "interaction": ["string", ["mouse", "voiceOver", "keyboard", "gesture", "tap"]],
                "trackingID": ["string"],
                "extVal": ["object"]
            }
        },
        "Event": {
            required: ["category", "event"],
            checkList: {
                "category": ["string"],
                "event": ["string"],
                "label": ["string"],
                "value": ["number"],
                "trackingID": ["string"],
                "extVal": ["object"]
            }
        },
        "Timing": {
            required: ["category", "value"],
            checkList: {
                "category": ["string"],
                "value": ["number"],
                "label": ["string"],
                "start": ["string"],
                "extVal": ["object"]
            }
        },
        "Counter": {
            required: ["category", "value"],
            checkList: {
                "category": ["string"],
                "value": ["number"],
                "label": ["string"],
                "extVal": ["object"]
            }
        },
        "Quality": {
            required: ["category", "value"],
            checkList: {
                "category": ["string", ["meeting", "audio", "video", "share"]],
                "value": ["string"],
                "extVal": ["object"]
            }
        },
        "Exception": {
            required: ["category", "value"],
            checkList: {
                "category": ["string"],
                "value": ["string"],
                "extVal": ["object"]
            }
        }
    };

    conf.TYPE = {
        AGENTINFO: "AgentInfo",
        INFO: "Info",
        PAGEVIEW: "PageView",
        SCREENVIEW: "ScreenView",
        ACTION: "Action",
        EVENT: "Event",
        TIMING: "Timing",
        COUNTER: "Counter",
        QUALITY: "Quality",
        EXCEPTION: "Exception"
    };

}());
/* End of file: doSchema.js */

/**
 * @Copyright 2016 Cisco Systems Inc. All rights reserved.
 * @Description This is a part of telemetry SDK.
 * @depends main.js, doSchema.js
 * @Author Xiaole Tao <xiaolet@cisco.com>
 * @File: validator.js
 * @Date 28/12/2016
 */
(function () {


    var doi = window.doi,
        conf = doi.conf,
        util = doi.util;

    /**
     * Error const define
     */
    var RESULT = conf._VALIDATERESULT = {
        PASSED: "Passed.",
        OBJECT_MISSED: "Validate object is missed.",
        REQUIRED_PARAM_MISSED: "Missed required parameter: \"{0}\".",
        UNDEFINED_TYPE: "\"{0}\" is not a expected type.",
        WRONG_VALUE_TYPE: "Wrong type of property: {0}.",
        WRONG_VALUE: "Wrong value of property: {0}.",
        UNACCEPTABLE_PARAM: "Parameter \"{0}\" is unexpected."
    };

    /**
     * generate validation return result
     * @param {boolean} result
     * @param {string} reason
     * @returns {{pass: *, reason: *}}
     * @private
     */
    function _genResult(result, reason) {
        return {pass: result, reason: reason};
    }

    /**
     * generate validation return result reason
     * @param {string} reason
     * @param {string} variable
     * @return {string}
     * @private
     */
    function _genReason(reason, variable) {
        return reason.replace(/\{0\}/, variable);
    }

    /**
     *
     * @param {string} type
     * @returns {boolean}
     * @private
     */
    function _checkType(type) {
        for (var key in conf.TYPE) {
            if (conf.TYPE[key] === type) {
                return true;
            }
        }
        return false;
    }

    /**
     *
     * @param {string} value
     * @param {array} valueList
     * @returns {boolean}
     * @private
     */
    function _isInEmnu(value, valueList) {
        return valueList.indexOf(value) !== -1;
    }

    /**
     * validate data with schema
     * @param {object} data
     * @returns {object}
     */
    function validate(data) {
        //miss data?
        if (!data) {
            return _genResult(false, RESULT.OBJECT_MISSED);
        }
        var values = data.values,
            type = data.type;
        //miss type?
        if (!type) {
            return _genResult(false, _genReason(RESULT.REQUIRED_PARAM_MISSED, "type"));
        }
        //miss values?
        if (!values) {
            return _genResult(false, _genReason(RESULT.REQUIRED_PARAM_MISSED, "values"));
        }
        //is type predefined?
        if (!_checkType(type)) {
            return _genResult(false, _genReason(RESULT.UNDEFINED_TYPE, type));
        }
        var checkModel = conf.validation[type],
            required = checkModel.required,
            checkList = checkModel.checkList;
        //miss required parameter?
        for (var index in required) {
            if (values[required[index]] === undefined) {
                return _genResult(false, _genReason(RESULT.REQUIRED_PARAM_MISSED, required[index]));
            }
        }
        //check every parameter
        for (var item in values) {
            //if this parameter has type limited
            if (checkList[item]) {
                //is value type right?
                if (typeof values[item] !== checkList[item][0]) {
                    return _genResult(false, _genReason(RESULT.WRONG_VALUE_TYPE, "\"" + item + "\" should be " + checkList[item][0]));
                }
                //is emnu type in emnu value list?
                if (checkList[item][1] && !_isInEmnu(values[item], checkList[item][1])) {
                    return _genResult(false, _genReason(RESULT.WRONG_VALUE, "\"" + item + "\" should be in array [" + checkList[item][1].join(", ") + "]"));
                }
            } else {
                return _genResult(false, _genReason(RESULT.UNACCEPTABLE_PARAM, item));
            }
        }
        //passed all check
        return _genResult(true, RESULT.PASSED);
    }

    /* istanbul ignore else: export private method for UT */
    //if (conf.isUT) {
    //    //only can see private method in unit test
    //    util._genResult = _genResult;
    //    util._genReason = _genReason;
    //    util._checkType = _checkType;
    //    util._isInEmnu = _isInEmnu;
    //}
    util.validate = validate;

}());
/* End of file: validator.js */

/**
 * @Copyright 2016 Cisco Systems Inc. All rights reserved.
 * @Description This is a part of telemetry SDK.
 * @Depends main.js
 * @Author Xiaole Tao <xiaolet@cisco.com>
 * @File io.js
 * @Date 04/07/2017
 */
(function () {


    var doi = window.doi,
        conf = doi.conf,
        util = doi.util,
        io = doi.io,
        _QUEUE = io._QUEUE = [],
        _SENDING = io._SENDING = [];

    /**
     * @return {string} sessionID
     */
    function getSessionID() {
        if (conf.TID) {
            return conf.TID;
        }
        return "";
    }

    /**
     * @param {string} key
     * @param {string} value
     */
    function setHeader(key, value) {
        conf.xhrHeader[key] = value;
    }

    /**
     * generate a random hex number
     * @param {number} len
     * @returns {string}
     * @private
     */
    function _genHexStr(len) {
        var base = "0123456789abcdef", hex = "";
        for (var i = 0; i < len; i++) {
            hex += base[Math.random() * 16 | 0];
        }
        return hex;
    }

    /**
     * get a 32 bytes uuid, format 8-4-4-4-12
     * @returns {string}
     * @private
     */
    function _genUUID() {
        var h = _genHexStr;
        return [h(8), h(4), h(4), h(4), h(12)].join("-");
    }

    /**
     * return a timestamp format follow RFC 822 timestamp
     * @returns {string}
     * @private
     */
    function _genStamp() {
        var now = new Date(),
            addPrefix = function (str, len) {
                return ("000" + str).slice(-len);
            },
            offset = addPrefix(-now.getTimezoneOffset() / 60 * 100, 4);
        return [
            addPrefix(now.getFullYear(), 4), "-", //year
            addPrefix(now.getMonth() + 1, 2), "-", //month
            addPrefix(now.getDate(), 2), "T", //day
            addPrefix(now.getHours(), 2), ":", //hour
            addPrefix(now.getMinutes(), 2), ":", //minute
            addPrefix(now.getSeconds(), 2), ".", //second
            addPrefix(now.getMilliseconds(), 3), //millisecond
            offset > 0 ? "+" : /* istanbul ignore next */ "-", offset //timezone
        ].join("");
    }

    /**
     * make _QUEUE to telemetry post data
     * @returns {string}
     * @private
     */
    function _makePostData() {
        var data = _QUEUE.splice(0, _QUEUE.length);
        if (conf.saveMode === "storage") {
            sessionStorage.removeItem("doiQueue");
        }
        if (conf.retryCounter) {
            _SENDING.push.apply(_SENDING, data);
        }
        return JSON.stringify({"telemetrics": data});
    }

    /**
     * save data to _QUEUE
     * @param {string} type
     * @param {object} values
     */
    function save(type, values) {
        var logger = conf.logger;

        var dataBlock = {
                type:   type,
                ts:     _genStamp(),
                tid:    conf.TID,
                cid:    conf.CID,
                pd:     conf.product,
                ver:    "2.0",
                values: values
            },
            quality = util.validate(dataBlock);

        if (!quality.pass) {
            logger.warn("[doi warn]Data validate failed, reason: " + quality.reason);
            logger.warn(dataBlock);
        }

        conf.retryCounter = conf.retry;
        _QUEUE.push(util.abbreviate(dataBlock));
        if (conf.saveMode === "storage") {
            sessionStorage.setItem("doiQueue", JSON.stringify(_QUEUE));
        }
    }

    /**
     * send all data from _QUEUE
     */
    function send() {
        var logger = conf.logger,
            header = conf.xhrHeader,
            isDone = false,
            xhr;

        //guard
        if (!conf.isInited) {
            logger.warn("[doi warn]doi initialed flag are false.");
            return;
        }

        conf.tickCounter = 0;

        if (_QUEUE.length) {
            /* istanbul ignore else: protect code */
            if (window.XMLHttpRequest) {
                xhr = new XMLHttpRequest();
                /* istanbul ignore next: IE protect */
            } else {
                xhr = new ActiveXObject("Microsoft.XMLHTTP");
                /* istanbul ignore next: XMLHttpRequest protect */
            }

            //xhr.open( Method, URL, Asynchronous, UserName, Password )
            xhr.open("POST", conf.URL, true);

            for (var key in header) {
                xhr.setRequestHeader(key, header[key]);
            }

            //watch sending
            /* istanbul ignore next: ut will not trigger this event */
            xhr.onreadystatechange = function () {
                /* istanbul ignore if: protect code */
                if (this.readyState === 4) {
                    if (this.status === 200) {
                        logger.info("[doi info]doi send data success.");
                        conf.retryCounter = conf.retry;
                    } else {
                        logger.warn("[doi warn]doi send data failed.");
                        if (conf.retryCounter) {
                            _QUEUE.push.apply(_QUEUE, _SENDING);
                            _SENDING.splice(0, _SENDING.length);
                        }
                        this.abort();
                    }
                    isDone = true;
                }
                /* istanbul ignore else */
            };

            /**
             * 1 minute watcher, if xhr still not finish, abort request
             */
            /* istanbul ignore next: ut can't waiting 1 minute so long */
            setTimeout(function () {
                /* istanbul ignore if: protect code */
                if (!isDone) {
                    xhr.abort();
                    logger.warn("[doi warn]doi send data failed, reason: timeout.");
                    isDone = true;
                }
                /* istanbul ignore else */
            }, 60000);

            //if have data send.
            logger.info("[doi info]doi sending start.");
            xhr.send(_makePostData());

            if (conf.retryCounter) {
                conf.retryCounter--;
            }
        }
    }

    /**
     * send pageView
     */
    function _savePageview() {
        save(conf.TYPE.PAGEVIEW, {
            title:    top.document.title,
            location: top.location.href
        });
    }

    /**
     * on ticker tick
     * @private
     */
    function _tickHandler() {
        if (++conf.tickCounter >= conf.interval * 10 && _QUEUE.length) {
            send();
        }
    }

    /**
     * setup SDK
     * @param {object} setting
     *      {string} saveMode - "memory"/"storage"]
     *      {number} interval - how long seconds to send metrics data to server once, default is 30
     *      {function} logger - logger, if user logger is not provide, console is the default logger
     *      {boolean} immediateSend - send data immediately, default is false
     *      {numbet} retry - before drop the data, how much times you want to test send, default is 3
     *      {string} sessionID - UUID
     */
    function setup(setting) {
        var logger = setting && setting.logger ? setting.logger : conf.logger || /* istanbul ignore next*/ console;

        if (!setting) {
            logger.error("[doi error]Parameter is empty.");
            return;
        }

        /**
         * {setting} > {conf} > {defaultValue}
         * @param name
         * @param defaultValue
         */
        function setValue(name, defaultValue) {
            if (setting[name] !== undefined) {
                conf[name] = setting[name];
            } else if (conf[name] !== undefined) {
                conf[name] = conf[name];
            } else {
                conf[name] = defaultValue;
            }
        }

        setting.TID = setting.sessionID;
        setting.noCache = setting.immediateSend;

        if (!setting.retry) {
            setting.retry = (setting.resendMatric === true) ? 3 : (setting.resendMatric === false) ? 0 : setting.resendMatric;
        }

        setValue("retry", 3);
        setValue("product", "unknown");
        setValue("interval", 300);
        setValue("TID", _genUUID());
        setValue("noCache", false);
        setValue("logger", logger);

        // conf.resendMetric = setting.resendMetric || conf.resendMetric || setting.resendMetric !== false || conf.resendMetric !== false;
        // conf.product = setting.product || conf.product || "unknow";
        // conf.interval = setting.interval || conf.interval || 300;
        // conf.logger = logger;
        // conf.TID = setting.sessionID || conf.TID || _genUUID();
        // conf.noCache = setting.immediateSend || conf.noCache || false;

        conf.retryCounter = conf.retry;
        conf.saveMode = "memory";
        if (setting.saveMode === "storage") {
            /* istanbul ignore else */
            if (window.sessionStorage) {
                var queue = sessionStorage.getItem("doiQueue");
                conf.storageEnable = true;
                /* istanbul ignore else */
                if (queue) {
                    _QUEUE = io._QUEUE = JSON.parse(queue);
                }
                conf.saveMode = "storage";
            }
        } else {
            conf.saveMode = "memory";
        }

        //TODO: dynamic CID
        conf.CID = _genUUID();
    }

    /**
     * initial SDK to prepare send
     * @param {object} setting
     *      {string} URL - telemetry server URL
     *      {string} appID - your app id
     *      other more...
     */
    function init(setting) {
        var logger = setting && setting.logger ? setting.logger : /* istanbul ignore next*/ console;

        /* istanbul ignore if: protect code */
        if (!window.XMLHttpRequest && /* istanbul ignore next */ !window.ActiveXObject) {
            logger.error("[doi error]Critical Err, require XMLHttpRequest support.");
            return;
        }

        if (!setting || !setting.URL || !setting.appID) {
            logger.error("[doi error]Missed required parameters to initial doi.");
            return;
        }

        setup(setting);
        conf.URL = setting.URL;
        conf.tickCounter = conf.tickCounter || 0;
        conf.isInited = true;

        setHeader("appId", setting.appID);
        setHeader("Content-Type", "text/plain");
        // setHeader("Connection", "close");
        setHeader("ver", "2.0");

        doi.ticker.onTick(_tickHandler);

        /* istanbul ignore if: protect code */
        if (typeof top !== "undefined") {
            _savePageview();
        }
        /* istanbul ignore else */
    }

    /* istanbul ignore else: export private method for UT */
    //if (conf.isUT) {
    //    //only can see private method in unit test
    //    io._savePageview = _savePageview;
    //    io._tickHandler = _tickHandler;
    //    io._genHexStr = _genHexStr;
    //    io._genUUID = _genUUID;
    //    io._genStamp = _genStamp;
    //    io._makePostData = _makePostData;
    //}
    io.init = init;
    io.setup = setup;
    io.getSessionID = getSessionID;
    io.setHeader = setHeader;
    io.save = save;
    io.send = send;

}());
/* End of file: io.js */

/**
 * @Copyright 2016 Cisco Systems Inc. All rights reserved.
 * @Description This is a part of telemetry SDK.
 * @depends main.js and io.js
 * @Author Xiaole Tao <xiaolet@cisco.com>
 * @File timing.js
 * @Date 11/01/2017
 */
(function () {


    var doi = window.doi,
        conf = doi.conf,
        io = doi.io;

    /**
     * {string} type: "Timing"
     * {object} values: {
     *     {string} category - required
     *     {number} value - required
     *     {object} extVal
     * }
     */
    var _timing = {
        trackingId: 1,
        anchor: {}
    }, anchor = _timing.anchor;

    /**
     * start a time tracking
     * @param {string} category
     * @param {number} timeout - seconds
     * @returns {number}
     */
    function startTimeTrace(category, timeout) {
        var logger = conf.logger;
        if (!category) {
            logger.error("[doi Error]Missed required parameter to start time trace.");
            return 0;
        }
        var trackingId = _timing.trackingId++;
        anchor[trackingId] = {
            trackingId: trackingId,
            startTime: +new Date(), // trackingId is current time
            category: category,
            countdown: +timeout || 120
        };

        return trackingId;
    }

    /**
     * finish a time tracking
     * @param {number} trackingId return of startTimeTrace
     */
    function sendTimeTrace(trackingId) {
        var logger = conf.logger, data = anchor[trackingId];
        if (!trackingId) {
            logger.error("[doi Error]Missed required parameter to send time trace.");
            return;
        }
        if (trackingId && data) {
            io.save(conf.TYPE.TIMING, {
                category: data.category,
                value: +new Date() - data.startTime
            });

            delete anchor[trackingId];
        }
    }

    /**
     * count down the timeout watching
     * @private
     */
    function _countdown() {
        var anchor = _timing.anchor;
        for (var index in anchor) {
            if (--anchor[index].countdown === 0) {
                io.save(conf.TYPE.EXCEPTION, {
                    category: anchor[index].category,
                    value: "timeout"
                });

                delete anchor[index];
            }
        }
    }

    //check timeout in every tick
    doi.ticker.onTick(_countdown);

    /* istanbul ignore else: export private method for UT */
    //if (conf.isUT) {
    //    //only can see private method in unit test
    //    conf._timing = _timing;
    //    io._countdown = _countdown;
    //}
    io.startTimeTrace = startTimeTrace;
    io.sendTimeTrace = sendTimeTrace;
}());
/* End of file: timing.js */

/**
 * @Copyright 2016 Cisco Systems Inc. All rights reserved.
 * @Description This is a part of telemetry SDK.
 * @Depends main.js, io.js
 * @Author Xiaole Tao <xiaolet@cisco.com>
 * @File: interface.js
 * @Date 27/12/2016
 */
(function () {


    var doi = window.doi,
        io = doi.io;

    /**
     * setup SDK
     * @param {object} setting
     *      {string} saveMode - "memory"/"storage"]
     *      {number} interval - how long seconds to send metrics data to server once, default is 30
     *      {function} logger - logger, if user logger is not provide, console is the default logger
     *      {boolean} immediateSend - send data immediately, default is false
     *      {string} sessionID - UUID
     */
    doi.setup = function (setting) {
        io.setup(setting);
    };

    /**
     * initial SDK to prepare send
     * @param {object} setting
     *      {string} URL - telemetry server URL
     *      {string} appID - your app id
     *      other more...
     */
    doi.init = function (setting) {
        io.init(setting);
    };

    /**
     * @return {string} sessionID
     */
    doi.getSessionID = function () {
        return io.getSessionID();
    };

    /**
     * @param {string} key
     * @param {string} value
     */
    doi.setHeader = function (key, value) {
        io.setHeader(key, value);
    };

    /**
     * send a telemetry data, type = "Info"
     * @param {object} values
     */
    doi.sendInfo = function (values) {
        doi.send("Info", values, false);
    };

    /**
     * send a telemetry data, type = "ScreenView"
     * @param {object} values
     */
    doi.sendScreenView = function (values) {
        doi.send("ScreenView", values, false);
    };

    /**
     * send a telemetry data, type = "Activity"
     * @param {object} values
     */
    doi.sendAction = function (values) {
        doi.send("Action", values, false);
    };

    /**
     * send a telemetry data, type = "Event"
     * @param {object} values
     */
    doi.sendEvent = function (values) {
        doi.send("Event", values, false);
    };

    /**
     * send a telemetry data, type = "Timing"
     * @param {object} values
     */
    doi.sendTiming = function (values) {
        doi.send("Timing", values, false);
    };

    /**
     * send a telemetry data, type = "Counter"
     * @param {object} values
     */
    doi.sendCounter = function (values) {
        doi.send("Counter", values, false);
    };

    /**
     * send a telemetry data, type = "Quality"
     * @param {object} values
     */
    doi.sendQuality = function (values) {
        doi.send("Quality", values, false);
    };

    /**
     * send a telemetry data, type = "Exception"
     * @param {object} values
     */
    doi.sendException = function (values) {
        doi.send("Exception", values, false);
    };

    /**
     * start a time tracking
     * @param {string} category
     * @param {number} timeout - seconds
     * @returns {number}
     */
    doi.startTimeTrace = function (category, timeout) {
        return io.startTimeTrace(category, timeout);
    };

    /**
     * finish a time tracking
     * @param {number} trackingId return of startTimeTrace
     */
    doi.sendTimeTrace = function (trackingId) {
        io.sendTimeTrace(trackingId);
    };

    /**
     * send a telemetry data, type = "Info"
     * @param {string} type
     * @param {object} values
     * @param {boolean} isImmediately
     */
    doi.send = function (type, values, isImmediately) {
        io.save(type, values);
        if (doi.conf.noCache || isImmediately) {
            io.send();
        }
    };

    /**
     * send all cached data
     */
    doi.sendImmediately = function () {
        io.send();
    };

    /**
     * send all cached data
     */
    doi.close = function () {
        io.send();
    };

}());
/* End of file: interface.js */
